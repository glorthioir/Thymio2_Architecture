#include "exploration.h"

#include "map.h"
#include "pathExecution.h"
#include "computePath.h"
#include "detection.h"
#include "orientation.h"



// This function takes as arguments an array of struct LittleCell "mapLilCell", an int tabular
// "pathFollowed", a string "map", an int "sizePath" and another int  "width"
// The function update the struct "mapLilCell" after a movement "pathFollowed" of the robot
// The path is defined by parameters "sizePath" and "width" 
// The map "map" is used for the update  
void updateLilCellMap(LittleCell* mapLilCell, int* pathFollowed, int sizePath, char* map, int width){
    int i, j;
    for(i=0; i<width; ++i){
        for(j=0; j<width; ++j){
            if(map[i*width+j] == 'x'){
                mapLilCell[i*width+j].obstacle = true;
                mapLilCell[i*width+j].explored = true;
            }
        }
    }
    
    for(i=0; i<sizePath; ++i)
        if(!mapLilCell[pathFollowed[i]].explored)
            mapLilCell[pathFollowed[i]].open = true;
    
}



// This function takes as arguments a "GDBusProxy", a string "filePath" and three int "speed",
// "width" and "sizeCell"
// The function run an exploration at the speed of move "speed" for the robot and 
// the robot write the map generated by this exploration in the file wich the repertory 
// is indicated by the path "filePath" 
// The created map is defined by the parameters "width" and "sizeCell"
// The value of "speed" must be between -500 and 500
void exploration(GDBusProxy *proxy, char* filePath, int speed, int width, int sizeCell){
    
    int orientation = 0;
    int i, j;
    
    LittleCell* mapLilCell = malloc(width * width * sizeof(LittleCell));
    char* map = malloc(width*width*sizeof(char));
    
    int iActual = (int)(width/2);
    int jActual = iActual;
    for(i=0; i<width; ++i){
        for(j=0; j<width; ++j){
            //mapLilCell[i*width+j].letter = 'o';
            map[i*width+j]='o';
            mapLilCell[i*width+j].obstacle = false;
            mapLilCell[i*width+j].open = false;
            mapLilCell[i*width+j].explored = false;
        }
    }
    
    /*
     mapLilCell[iActual*width+jActual].letter = 'b'; // Approx the middle of the map
     mapLilCell[iActual*width+jActual].explored = true;
     */
    
    bool over = false;
    while (!over) {
        
        
        //mapLilCell[iActual*width+jActual].letter = 'b'; // Approx the middle of the map at the beginning
        map[iActual*width+jActual] = 'b';
        mapLilCell[iActual*width+jActual].explored = true;
        mapLilCell[iActual*width+jActual].open = false;
        
        // Check and open the 8 cells around the actual one
        
        // Top cell
        if( (iActual-1) >=0 && !mapLilCell[(iActual-1)*width+jActual].explored){
            orientateTo(proxy, orientation, 0);
            orientation = 0;
            
            if(detectFrontObstacle(proxy)){
                //mapLilCell[(iActual-1)*width+jActual].letter = 'x';
                map[(iActual-1)*width+jActual] = 'x';
                mapLilCell[(iActual-1)*width+jActual].explored = true;
            }
            else{
                mapLilCell[(iActual-1)*width+jActual].open = true;
            }
        }
        
        /*
         // Top-right cell
         if(&& (iActual-1) >=0 &&(jActual+1) < width && !mapLilCell[(iActual-1)*width+(jActual+1)].explored){
         orientateTo(proxy, orientation, 315);
         orientation = 315;
         
         if(detectFrontObstacle(proxy)){
         //mapLilCell[(iActual-1)*width+(jActual+1)].letter = 'x';
         map[(iActual-1)*width+(jActual+1)] = 'x';
         mapLilCell[(iActual-1)*width+(jActual+1)].explored = true;
         }
         else{
         mapLilCell[(iActual-1)*width+(jActual+1)].open = true;
         }
         }
         */
        
        
        // Right cell
        if(!mapLilCell[iActual*width+(jActual+1)].explored && (jActual+1) < width){
            orientateTo(proxy, orientation, 270);
            orientation = 270;
            
            if(detectFrontObstacle(proxy)){
                //mapLilCell[iActual*width+(jActual+1)].letter = 'x';
                map[iActual*width+(jActual+1)] = 'x';
                mapLilCell[iActual*width+(jActual+1)].explored = true;
            }
            else{
                mapLilCell[iActual*width+(jActual+1)].open = true;
            }
        }
        
        /*
         // Bottom-right
         if(!mapLilCell[(iActual+1)*width+(jActual+1)].explored && (iActual+1) < width && (jActual+1) < width){
         orientateTo(proxy, orientation, 225);
         orientation = 225;
         
         if(detectFrontObstacle(proxy)){
         //mapLilCell[(iActual+1)*width+(jActual+1)].letter = 'x';
         map[(iActual+1)*width+(jActual+1)] = 'x';
         mapLilCell[(iActual+1)*width+(jActual+1)].explored = true;
         }
         else{
         mapLilCell[(iActual+1)*width+(jActual+1)].open = true;
         }
         }
         */
        
        
        // Bottom
        if(!mapLilCell[(iActual+1)*width+jActual].explored && (iActual+1) < width){
            orientateTo(proxy, orientation, 180);
            orientation = 180;
            
            if(detectFrontObstacle(proxy)){
                //mapLilCell[(iActual+1)*width+jActual].letter = 'x';
                map[(iActual+1)*width+jActual] = 'x';
                mapLilCell[(iActual+1)*width+jActual].explored = true;
            }
            else{
                mapLilCell[(iActual+1)*width+jActual].open = true;
            }
        }
        
        
        /*
         // Bottom-left
         if(!mapLilCell[(iActual+1)*width+(jActual-1)].explored && (iActual+1) < width && (jActual-1) >= 0){
         orientateTo(proxy, orientation, 135);
         orientation = 135;
         
         if(detectFrontObstacle(proxy)){
         //mapLilCell[(iActual+1)*width+(jActual-1)].letter = 'x';
         map[(iActual+1)*width+(jActual-1)] = 'x';
         mapLilCell[(iActual+1)*width+(jActual-1)].explored = true;
         }
         else{
         mapLilCell[(iActual+1)*width+(jActual-1)].open = true;
         }
         }
         */
        
        // Left
        if(!mapLilCell[iActual*width+(jActual-1)].explored && (jActual-1) >= 0){
            orientateTo(proxy, orientation, 90);
            orientation = 90;
            
            if(detectFrontObstacle(proxy)){
                //mapLilCell[iActual*width+(jActual-1)].letter = 'x';
                map[iActual*width+(jActual-1)] = 'x';
                mapLilCell[iActual*width+(jActual-1)].explored = true;
            }
            else{
                mapLilCell[iActual*width+(jActual-1)].open = true;
            }
        }
        
        /*
         // Top-left
         if(!mapLilCell[(iActual-1)*width+(jActual-1)].explored && (iActual-1) >=0 && (jActual-1) >= 0){
         orientateTo(proxy, orientation, 45);
         orientation = 45;
         
         if(detectFrontObstacle(proxy)){
         //mapLilCell[(iActual-1)*width+(jActual-1)].letter = 'x';
         map[(iActual-1)*width+(jActual-1)] = 'x';
         mapLilCell[(iActual-1)*width+(jActual-1)].explored = true;
         }
         else{
         mapLilCell[(iActual-1)*width+(jActual-1)].open = true;
         }
         }
         */
        
        
        
        
        /*
         // 4 orientations can be problematic : 45, 135, 225 and 315
         // we'll do a 45 degree rotation to the right to correct this issue
         if(orientation == 45 || orientation == 135 || orientation == 225 || orientation == 315){
         turnRight(proxy, 45, speed, 4.90);
         orientation -= 45;
         }
         */
        
        // New cell to go to : check the cells around OR find one open further using path thingy
        
        
        
        
        int range, step, active1=0, active2=0, active3=0, active4=0, iToTest, jToTest;
        bool cellFound = false;
        int iObj=iActual, jObj=jActual;
        
        for(range=1; range<width; ++range){ // for each progressive range we need to do 4 sides (top side, right, bot and left)
            for(step=0; step<4; ++step){
                switch (step) {
                    case 0:
                        active1 = -1;
                        active2 = 0;
                        active3 = -1;
                        active4 = 1;
                        break;
                        
                    case 1:
                        active1 = -1;
                        active2 = 1;
                        active3 = 1;
                        active4 = 0;
                        break;
                        
                    case 2:
                        active1 = 1;
                        active2 = 0;
                        active3 = 1;
                        active4 = -1;
                        break;
                        
                    case 3:
                        active1 = 1;
                        active2 = -1;
                        active3 = -1;
                        active4 = 0;
                        break;
                        
                    default:
                        break;
                }
                
                
                for(i=0; i<=2*range; ++i){
                    iToTest = (iActual+range*active1+i*active2);
                    jToTest = (jActual+range*active3+i*active4);
                    if(iToTest >= 0 && jToTest >= 0 && iToTest < width && jToTest < width){ // We are not out of the table
                        if(mapLilCell[iToTest * width + jToTest].open){
                            cellFound = true;
                            iObj = iToTest;
                            jObj = jToTest;
                            printf("Obj : %d %d\n", iToTest, jToTest);
                            
                            //mapLilCell[iObj * width + jObj].letter = 'e';
                            map[iObj * width + jObj]='e';
                            
                            
                            // For debug :
                            int a, b;
                            printf("\n\n\n");
                            
                            for(a=0; a<width; ++a){
                                for(b=0; b<width; ++b){
                                    if(mapLilCell[a*width+b].open){
                                        if(map[a*width+b] == 'e')
                                            printf("e");
                                        else
                                            printf("o");
                                    }
                                    else
                                        if(map[a*width+b] == 'b')
                                            printf("b");
                                        else
                                            if(mapLilCell[a*width+b].explored)
                                                printf("x");
                                            else
                                                printf("i");
                                }
                                printf("\n");
                            }
                            // end debug
                            
                            
                            break;
                        }
                    }
                }
                
                if(cellFound)
                    break;
            }
            if(cellFound)
                break;
        }
        
        
        
        
        
        
        
        if(!cellFound) // We check the whole map, everything has been explored
            over = true;
        
        if(cellFound){ // We found a cell, we need to check it
            int sizePath;
            int* pathToFollow = pathToTarget(&sizePath, map, width, width);
            if(sizePath == -1){
                printf("Cell found but no path to get to it...\n");
                
                //return;
            }
            orientation = executePathChecked(proxy, speed, map, width, width, pathToFollow, &sizePath, sizeCell, orientation);
            
            if(sizePath == -1){
                printf("Cell found but no path to get to it...\n");
                
                //return;
            }
            
            
            // Update
            if(sizePath != -1){ // went to the expected cell
                //map[iObj*width+jObj]='b';
                map[iActual*width+jActual]='o';
                //iActual=iObj;
                //jActual=jObj;
                updateLilCellMap(mapLilCell, pathToFollow, sizePath, map, width);
                if(sizePath != -1)
                    free(pathToFollow);
            }
            if (sizePath == -1) {
                for(i=0; i<width; ++i){
                    for(j=0; j<width; ++j){
                        if(map[i*width+j] == 'x'){ // Update the map
                            mapLilCell[i*width+j].open = false;
                            mapLilCell[i*width+j].explored = true;
                        }
                        
                        if(map[i*width+j] == 'e'){ // Can't reach it
                            mapLilCell[i*width+j].open = false;
                            mapLilCell[i*width+j].explored = true;
                            map[i*width+j] = 'x';
                        }
                        
                        
                    }
                }
            }
            for(i=0; i<width; ++i){
                for(j=0; j<width; ++j){
                    if(map[i*width+j] == 'b'){
                        iActual = i;
                        jActual = j;
                    }
                }
            }
            
        }
        
        
    }
    
    
    
    for(i=0; i<width; ++i){
        for(j=0; j<width; ++j){
            printf("%c",map[i*width+j]);
        }
        printf("\n");
    }
    
    
    writeMap(filePath, map, width, width, sizeCell);
    free(map);
    
}




